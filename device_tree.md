https://github.com/devicetree-org/devicetree-specification/releases


Introduction to Devicetree

    Devicetree is a data structure which gives the description about the devices in the system.
    Earlier there were no devicetrees in specific, but the hardware configurations were embedded with kernel source as header files.
    This means that the details of the machine were hard coded.
    Drawback was the kernel image which is built, is specific for a platform(board) and also increases the kernel source code making it trashy.
    The solution is the device tree, which is a data structure describing the hardware and readable by the operating system.
    Device tree source(.dts) is specific for a board, containing board level definitions.
    While Device tree source included(.dtsi) contains SoC level definitions.
    dts can include .dtsi files, which makes it easy to add specific information for a board and prevents coding from scratch.

For example, bcm2837-rpi-3-b.dts is a device tree source for Raspberry Pi3 board, this file includes bcm2837.dtsi, bcm2835-rpi.dtsi, bcm283x-rpi-smsc9514.dtsi. These dtsi files in turn may also include dtsi file or header(.h) files.
Device tree source

    Devicetree is a construct specified by the DTSpec to describe system hardware.
    Current DTSpec is release v0.2 by devicetree.org[[1]DTSpec]
    Device tree source has a tree structure with root and nodes.
    Root is represented by '/'
    Node describes the devices in the system.
    Device description is given by the properties and the value pairs in the node.
    The name of DTS file should end with .dts

Below is an example representation of a simple devicetree that is nearly complete enough to boot a simple operating system, with the platform type, CPU, memory and a single UART described.
Device tree example
Device tree Structures

    Node name:

The node name specifies the name of the node.

 node-name@unit-address

unit-address must specify the first address in the reg property ex: cpu@0 uart@7e201000

    Path name:

Specifies the full path to the node from root. A node can be identified in the device tree by specifying the full path to the node from the root. ex: /cpus/cpu@0

Nodes:

    As defined earlier, nodes represents the devices in the system.
    A devicetree should contain atleast one cpu and memory node.

Nodes in Devicetree

    Root Node

Devicetree contains only one root node represented by '/' Table below gives the properties and the values used by the root node.
Root.png

    /cpus

Does not represent a real device, acts as a container for all child cpu nodes.
Cpus.png

/cpus/cpu * Child node of /cpus node. Represents the CPU cores. * indicates the cpu number starting from 0. device_type property can be included only for cpu and memory node.
Cpu.png

    /memory

Describes the physical memory layout for the system.
Memory.png

    /chosen

Describes parameters chosen or specified by the system firmware at run time.
Chosen.png

    /aliases

Each property of the /aliases node defines an alias. The property name specifies an alias name. The property value specifies full path to a node in the devicetree. Ex: serial0 = "/soc/serial@7e201000"

Other important properties:

    phandle

 property name : phandle
 property value : <u32>

This property is used to specify a numerical identifier for a node. The value can be used by other node to refer to this node with phandle. The phandle value of a node is unique within the devicetree.
Ex:
Phandle.png

device_node refers to the interrupt controller pic@10000000 by using phandle value.

    status

 property name : status
 property value : <string>

Indicates the operational status of a device.
Status.png

    Labels

Labels can be attached to any node or property in DTS. Phandle and path references can be automatically generated by referencing a label instead of explicitly specifying a phandle value or the full path to a node. Labels are only used in the devicetree source format and are not encoded into the DTB binary. Labels are created by appending colon(:) to the label name given to a node or property and can be referenced by using ampersand(&) with label name.

For the representation mentioned in the fig: Device tree example, .dts file format is given below.
Dts1.png


Device tree compilation

    Device tree blob(.dtb) is compact binary representation of Device tree.
    dts can be compiled by using makefile in the kernel source directory using below command,

                                                    $ make  dtbs

or

                                             $ make bcm2837-rpi-3-b.dts

    dts can be compiled using DTC(Device tree compiler)
    The source code for device tree compiler is present in scripts/dtc/ of Linux kernel source code directory, which can be built to form an executable i.e, dtc.
    The other way to get DTC is to install the DTC packages using below command,

                                    $ sudo apt-get install device-tree-compiler

    DTC cannot preprocess the preprocessor directives starting with '#'. If include file is #include ”file_name.dtsi” then the # can be replaced with '/' like /include/” file_name.dtsi”. But this replacement throws an error if there is .h file (Because DTC do not have a preprocessor!). So the dts file should be preprocessed before compilation using the C preprocessor(cpp).

 $ cpp -nostdinc  -I include -undef -x assembler-with-cpp arch/arm/boot/dts/bcm2837-rpi-3-b.dts \
  arch/arm/boot/dts/bcm2837-rpi-3-b.preprocessed

Flags used in cpp:

    -nostdinc - Do not search for standard directories for header files, search only directories specified with -I and the current directory of the file
    -I dir - add the directory "dir" to the list of directory to be searched for header files
    -undef - Do not predefine any GCC/system specific macros
    -x - Specifies source language(c, c++, assembler-with-cpp)

                                 $ dtc -I dts -O dtb bcm837-rpi-3-b.preprocessed -o bcm2837-rpi-3-b.dtb

Flags used in dtc:

    -I - input format
    -O - output format
    -o - output file

.dts files can be re-created from .dtb using DTC. But the .dts file created will be having the combined information from the .dtsi files and .dts files which was used to create a .dtb.
Flattened devicetree(FDT) structure

    The Devicetree blob(DTB) format is a flat binary encoding of device tree, also called as Flattened devicetree(FDT).
    FDT structure consists fdt header followed by memory reservation block, structure block and string block.
    When the DTB is loaded into memory, it resembles the diagram below

.dtb structure

Frees space may be present between the blocks to satisfy the alignment constraint of each block. Now we will look into the header and blocks.

    struct fdt_header

This structure is declared in fdt.h . Structure members are 32-bit unsigned integers typedef to fdt32_t and are in big-endian format.
Struct fdt.png

magic number is used to identify the .dtb file and the value is 0xd00dfeed.

    Memory reservation block

Provides client program list of areas in memory which are reserved.
Reserve.png

Each pair gives the physical address and size in bytes of a reserved memory region.

    Structure block

Describes the structure and contents of devicetree. It is composed of sequence of tokens and data.

    The FDT_BEGIN_NODE(0x00000001) token marks the beginning of a node’s representation
    The FDT_END_NODE (0x00000002) token marks the end of a node’s representation.
    The FDT_PROP (0x00000003) token marks the beginning of the representation of one property in the devicetree.

Fdt prop.png

len gives length of property's value and nameoff gives offset to the string block.

    The FDT_NOP (0x00000004) token will be ignored by any program parsing the device tree
    The FDT_END (0x00000009) token marks the end of the structure block.
    String block

Contains strings representing all the property names used in the tree. Referred from the structure block by an offset into the string block.
FAQ

1. How the DTB is passed to kernel?

    If there is no bootloader then start.elf passes the dtb to kernel, if U-Boot is used as bootloader then it invokes the kernel entry point passing the address of the dtb image in RAM as one of the parameters. kernel_entry function pointer passes the dtb address to the kernel.

References

    zedboard.org
    DTSpec - https://github.com/devicetree-org/devicetree-specification/releases
    https://elinux.org/images/f/f9/Petazzoni-device-tree-dummies_0.pdf
