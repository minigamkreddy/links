SPI
https://www.kernel.org/doc/html/v4.14/driver-api/spi.html
https://www.kernel.org/doc/html/v4.14/driver-api/spi.html
https://www.kernel.org/doc/html/v4.14/driver-api/spi.html
https://www.kernel.org/doc/html/v4.14/admin-guide/index.html


Installation & Setup

    Download Raspberry Pi OS from raspberrypi.org and flash it on SD Card.
	https://www.raspberrypi.org/
    For cross compilation refer procedure given on raspberry pi's .website
	https://www.raspberrypi.org/documentation/linux/kernel/building.md
    Have a zImage of the kernel in the sd card.

Enabling SPI Ports on Raspberry Pi

    Open the terminal and type "raspi-config".
    Go to interfacing options and enable "SPI".
    Reboot your Raspberry Pi.

Configuring Ports
Interfacing options.png
Spi menu.png
Interfacing ADC with Raspberry Pi
ADC MCP3202 Pins 	Raspberry Pi Ports
CS 	SPI0 CS0
CH0 	External Input Voltage
CH1 	External Input Voltage
Vss 	+5V
Din 	SPI0 MOSI
Dout 	SPI0 MISO
SCLK 	SPI0 SCLK
GND 	Ground

Note:

These connections are for SPI0 Port, you can connect ADC with SPI1 also.

Read Datasheet of ADC "MCP3202" carefully for initialization of chip, channel configuration & serial communication using shift register.
Serial Peripheral Interface

It is a synchronous serial communication interface used for short distance communication, specially in embedded systems. SPI was developed by Motorola in the mid 1980s and has become a de facto standard.

SPI devices communicate in full duplex mode using a master-slave architecture with a only one master. With individual slave select (SS) lines particular slave device can be selected amongst multiple slave devices.

SPI is also called a four-wire serial bus. It is simple and efficient protocol used in the Embedded Systems and hardware required is also simple(just a Shift Register).

    SPI has 4 Pins
        SCLK - "Serial Clock" generated by Master.
        MOSI - "Master Out Slave In" (Data Out pin for Master).
        MISO - "Master In Slave Out" (Data in pin for Master).
        CS/SS - "Chip Select/Slave Select" for selecting particular slave device.

Pins.png
Simple SPI Communication

Master configures the clock to start communication. The master then selects the slave device by pulling the particular select line to LOW.

During each clock cycle, a full duplex data transmission occurs. The master sends a bit on the MOSI line and the slave reads it, while the slave sends a bit on the MISO line and the master reads it. This sequence is maintained even when only one-directional data transfer is intended.

Transmissions involve two shift registers of given size, one in the master and one in the slave. Data is usually shifted out with the MSB first. On the clock edge, both master and slave shift out a bit. On the next clock edge, at each receiver the bit is sampled from the transmission line and set as a new least-significant bit of the shift register. After the register bits have been shifted out and in, the master and slave have exchanged register values. If more data needs to be exchanged, the shift registers are reloaded and the process repeats. Transmission may continue for any number of clock cycles. When complete, the master stops toggling the clock signal, and deselects the slave.
Working.png
SPI Modes

SPI Has 4 operating modes depending upon CPOL & CPHA.

    CPOL is Clock Polarity
        CPOL=0 is a clock which idles at 0, and each cycle consists of a pulse of 1. The leading edge is a rising edge, and the trailing edge is a falling edge.
        CPOL=1 is a clock which idles at 1, and each cycle consists of a pulse of 0. The leading edge is a falling edge, and the trailing edge is a rising edge.

    CPHA is Clock Phase
        For CPHA=0, the data changes on the trailing edge of the preceding clock cycle, captures on the leading edge of the clock cycle. Data is valid until the trailing edge of the current clock cycle. For the first cycle, the first bit must be on the MOSI line before the leading clock edge.
        For CPHA=1, the data changes on the leading edge of the current clock cycle, captures on the trailing edge of the clock cycle. Data is valid until the leading edge of the following clock cycle.

Modes 	CPOL 	CPHA
0 	0 	0
1 	0 	1
2 	1 	0
3 	1 	1

    SPI Mode decides Sampling Edge and Toggling Edge for the data.
    SPI interface transmit and receive data simultaneously on MOSI and MISO.
    Clock polarity (CPOL) and clock phase (CPHA) define a clock format to be used by the SPI bus.
    Depending on CPOL parameter, SPI clock may be inverted or non-inverted. CPHA parameter is used to shift the sampling phase.
        E.g. - If CPHA=0 the data are sampled on the leading (first) clock edge. If CPHA=1 the data are sampled on the trailing (second) clock edge, regardless of whether that clock edge is rising or falling.

0123.png

    Mode 0

The clock idle state is zero. The data must be available before the first rising clock signal. The data on MISO and MOSI lines must be stable while the clock is high and can be changed when the clock is low. The data is captured on the clock's low-to-high transition and propagated on high-to-low clock transition.

    Mode 1

The clock idle state is zero. The first rising clock signal can be used to prepare the data. The data on MISO and MOSI lines must be stable while the clock is low and can be changed when the clock is high. The data is captured on the clock's high-to-low transition and propagated on low-to-high clock transition.

    Mode 2

The clock idle state is one. The data must be available before the first falling clock signal. The data on MISO and MOSI lines must be stable while the clock is low and can be changed when the clock is high. The data is captured on the clock's high-to-low transition and propagated on low-to-high clock transition.

    Mode 3

The clock idle state is one. The first clock signal falling can be used to prepare the data. The data on MISO and MOSI lines must be stable while the clock is high and can be changed when the clock is low. The data is captured on the clock's low-to-high transition and propagated on high-to-low clock transition.
M0123.png
Working of Shift Register

    These type of registers used in the SPI communication receives the number of bits same as that of transmitted bits simultaneously.
    If it transmits single bit from one end, simultaneously, it receives single bit at other end (Full Duplex).

Shift reg.png
Advantages & Disadvantages
Adv disadv.png
Initialization of ADC
Initialization of ADC

    Communication is done by pulling CS pin low.
    DIN will constitute a start bit.
    SGL/DIFF bit and ODD/SIGN bit follow the start bit.
    Then MSBF bit is transmitted.

Initialization Bits of ADC "MCP3202"

    SGL/DIFF – For selecting Single-Ended mode or Pseudo-differntial mode.
    ODD/SIGN – For selecting one of the Channels in Single-Ended mode & Polarity in Pseudo-differntial mode.
    MSBF – For selecting MSB first or LSB first data format.

(For configuration of above bits refer table given in datasheet of MCP3202)
Adc init.png
Device Tree

    A device tree is a tree data structure with nodes that describe the physical devices in a system.
    On ARM all device tree source are located at /arch/arm/boot/dts/.
    Device tree compiler (dtc) is used to compile dts files and produce .dtb.
    The Device Tree Blob(.dtb) is the binary that gets loaded by the bootloader and parsed by the kernel at boot time.

Dt.png

To compile .dts file use the below commands :

IDE=<your-device-name>

SRC=$IDE.dts

TMP=$IDE.tmp.dts

DST=$IDE.dtb

cpp -nostdinc -I include -undef -x assembler-with-cpp $SRC > $TMP

dtc -O dtb -b 0 -o $DST $TMP

rm $TMP

For more information , refer this.
Linux SPI Device Driver

This is a generalized interface to declare SPI buses & devices and functionalities of SPI.

We need to manage them according to the standard Linux driver model and perform input/output operations...!!!
Some useful structures from API

    struct spi_master
    struct spi_device
    struct spi_board_info
    struct spi_driver
    struct spi_message
    struct spi_transfer

SPI Device Driver Implementation

Generally, Linux SPI Device Driver has two types, Controller Driver & Protocol Driver. Controller driver used to abstract controller hardware. All SPI devices are the children of controller driver. We need to write SPI protocol driver in order to communicate with Slave device.

Here, I have treated SPI slave as character device and, according to that, I have developed character device driver.
Initialaztion function for driver module

module_init() :

    Setting up a char device - alloc_chrdev_region()
    Allocate and register structure of type struct cdev - cdev_alloc()
    Tell the kernel about it - cdev_add()
    Create the class of character device - class_create()
    Create the device of the class - device_create()
    Register spi driver to the Kernel - spi_register_driver()

Probing of Device

probe() : Purpose of probe() function is to detect devices residing on the bus & to create device nodes corresponding to these devices. The kernel calls the driver's probe() function once for each device. Probe function starts the per-device initialization: initializing hardware, allocating resources, and registering the device with the kernel.

    In order to probe the slave device, it is essential to make entry in the appropriate .dts(device tree source) file of board on which you are working (Raspberry Pi, in this case).
    Once you make the entry in DTS, you need to compile the DTS file using DTC(Device Tree Compiler).
    Again you need to built the kernel and boot the Raspberry-Pi.

Reading from ADC

read() : This function needs to send command to initialize ADC and simultaneously read the conversion data from ADC, in its receiver buffer.

Functions & structures used by read -

    struct spi_transfer
    struct spi_message
    spi_message_init()
    spi_message_add_tail()
    spi_sync()

SPI Application Implementation

In application, you need to open SPI device present in /dev directory using open() system call. Then read the values of registers using read() system call and close the device using close() system call.
Spi app.png
Snapshots of Setup and Results
Spi setup.png
Spi results.png
Linux SPI Device Driver Presentation files

Link for this will be available soon.
FAQ's

    SPI Device Driver - FAQ'S

References

    https://www.kernel.org/doc/Documentation/spi/spi-summary
    http://ww1.microchip.com/downloads/en/DeviceDoc/21034D.pdf
    https://www.kernel.org/doc/html/v4.14/driver-api/spi.html
    https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi#res
    http://dlnware.com/theory/SPI-Transfer-Modes
    http://ww2.cs.fsu.edu/~rosentha/linux/2.6.26.5/docs/DocBook/kernel-api/ch25.html
    https://e2e.ti.com/support/embedded/linux/f/354/t/518439
    http://www.farnell.com/datasheets/1669376.pdf
    https://www.raspberrypi.org/
    https://elinux.org/Device_Tree_Reference
    https://www.raspberrypi.org/documentation/linux/kernel/building.md




Installation and Setup

    Download Raspberry Pi OS from raspberrypi.org and flash it on SD Card.(Link to download[[1]])

 // Flash raspbian image to SD card
 $ sudo dd if=2018-03-13-raspbian-stretch.img of=/dev/sdc status=progress
 // Connect USB to serial Cable:
  - Connect Green color wire of serial cable to Pin10[RXD] of Raspberry Pi 3
  - Connect White color wire of serial cable to Pin8[TXD] of Raspberry Pi 3

    For cross compilation refer procedure given on raspberry pi's website.click here to navigate[2]

    Have a zImage of the kernel in the SD card.

Enabling I2C Ports on Raspberry Pi

    Open the terminal and type "raspi-config".

    Go to interfacing options.

    Enable "I2C"

    Reboot your Raspberry Pi.


Interfacing options.png



Raspi-config.png



Enable i2c.png


Now , the i2c ports are enabled!!!!


Interfacing RTC with Raspberry Pi 3b
RTC DS1307 Pins 	Raspberry Pi Ports
SDA 	GPIO02 SDA1(pin - 03)
SCL 	GPIO03 SCL1(pin - 05)
VCC 	+5V(pin - 02 or 04)
GND 	Ground
Real Time Clock(RTC) DS1307
RTC DS1307.jpg

    Real-time clock (RTC) counts seconds, minutes, hours, date of the month, month, day of the week, and year.
    56-byte, battery-backed, nonvolatile (NV)RAM for data storage.
    Two-wire serial interface.
    Available in 8-pin DIP or SOIC.
    The DS1307 uses an external 32.768kHz crystal.
    The RTC registers are located in address locations 00h to 07h.
    The RAM registers are located in address locations 08h to 3Fh.
    The contents of the time and calendar registers are in the BCD format.

RTC Registers
RTC Registers.png
Device Tree

    A device tree is a tree data structure with nodes that describe the physical devices in a system.
    On ARM all device tree source are located at /arch/arm/boot/dts/.
    Device tree compiler (dtc) is used to compile dts files and produce .dtb.
    The Device Tree Blob(.dtb) is the binary that gets loaded by the bootloader and parsed by the kernel at boot time.


Rtc dts.png

To compile .dts file use the below commands :

IDE=<your-device-name>

SRC=$IDE.dts

TMP=$IDE.tmp.dts

DST=$IDE.dtb

cpp -nostdinc -I include -undef -x assembler-with-cpp $SRC > $TMP

dtc -O dtb -b 0 -o $DST $TMP

rm $TMP

For more information , refer [3]
Linux I2C Device Driver

This is a generalized interface to declare I2C buses & devices and functionalities of I2C.

We need to manage them according to the standard Linux driver model and perform input/output operations...!!!
Important structures

    struct i2c_driver[4]
    struct i2c_client[5]
    struct i2c_board_info[6]
    struct i2c_algorithm[7]
    struct i2c_adapter
    struct i2c_message

I2C Device Driver Implementation

Here, I have treated I2C slave as character device and, according to that, I have developed character device driver.
Initialization function for driver module

module_init() :

    Setting up a char device - alloc_chrdev_region()
    Allocate and register structure of type struct cdev - cdev_alloc()
    Tell the kernel about it - cdev_add()
    Create the class of character device - class_create()
    Create the device of the class - device_create()
    Register i2c driver to the Kernel - i2c_add_driver()

Probing of Device

probe() : Purpose of probe() function is to detect devices residing on the bus & to create device nodes corresponding to these devices. The kernel calls the driver's probe() function once for each device. Probe function starts the per-device initialization: initializing hardware, allocating resources, and registering the device with the kernel.

    In order to probe the slave device, it is essential to make entry in the appropriate .dts(device tree source) file of board on which you are working (Raspberry Pi, in this case).
    Once you make the entry in DTS, you need to compile the DTS file using DTC(Device Tree Compiler)(Refer above section)[[8]].

Codeflow of Probe

i2c_add_driver() :

    We tell the kernel about our I2C slave driver by registering the 'struct i2c_driver' structure with the I2C core.The id_table member allows us to tell the framework which I2C slaves chips are supported.
    When the device and driver name matches, then internally the probe function will be invoked.


Code flow probe.png


Communication with the device

    Now, once the device is detected and driver is registered.. Next part is to communicate with the device. Below are some api's which help to communicate.

i2c_transfer() :

    Helps in transferring a single or combined I2C message.

i2c_master_send() :

    Helps in communicating a single I2C message in master transmit mode.

i2c_master_recv() :

    Helps in communicating a single I2C message in master receive mode.

For more detail, refer[9]
I2C Application Implementation

In application, you need to open I2C device present in /dev directory using open() system call.

Then read the values of registers using read() system call or write the values into the device registers using write() system call and close the device using close() system call.

Once the driver code is ready, insert the kernel module using command: insmod module_name.ko

Then compile and execute the application.
From Application to the device
App to device.png
Snapshots of Setup and Results
Rtc rpi setup.png


Result i2c.png
References

    http://wiki.dreamrunner.org/public_html/Embedded-System/Linux-Device-Tree.html
    https://learn.sparkfun.com/tutorials/i2c
    https://www.nxp.com/docs/en/user-guide/UM10204.pdf
    http://www.ti.com/lit/an/slva704/slva704.pdf
    https://datasheets.maximintegrated.com/en/ds/DS1307.pdf

FAQ

Question 1: How many devices can be connected to the I2C bus?

Answer  : I2C specifies 2 address lengths, 7 and 10 bits, which gives a theoretical maximum of 128 and 1024 distinct address, respectively.However, there are a few reserved addresses.But practically it depends on the bus capacitance.

Question 2: What is pull up resistor?

Answer  : If there is nothing connected to the pins of MCU, and if program tries to read the state of that pin, the state will be unknown.This is called floating phenomena. In order to prevent this , floating pins are pulled up (or pulled down) to a specific voltage using the resistor called pull up resistor.

Question 3: What is Arbitration?

Answer  : In I2C multiple masters can be connected to the bus. By constantly monitoring SDA and SCL for start and stop conditions, they can determine whether the bus is currently free or not. If the bus is busy, masters has to wait until a stop condition indicates that the bus is free again for their data transfer.But , there is a probability that two masters start a transfer at the same time. During the transfer, the masters constantly monitor SDA and SCL. If one of them detects that SDA is low when it should actually be high, it assumes that another master is active and immediately stops its transfer. This process is called arbitration.

Question 4:Is I2C slave driver and I2C client driver both are same/different?

Question 5:I2C is hot pluggable or not? 
